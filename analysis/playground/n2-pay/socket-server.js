const net = require("node:net");
const { inspect } = require("node:util");
const fs = require("fs");
const path = require("node:path");
const { Transform } = require("node:stream");

const clientMessageFilePath = path.resolve(
  "playground/n2-pay/client-message.txt"
);
const clientMessageFileStream = fs.createWriteStream(clientMessageFilePath);

const log = (...args) => {
  args.forEach((arg) => console.log(inspect(arg, true, Infinity, true)));
};

const messageReplyByCommandCode = [
  {
    // free command
    code: 1,
    args: { admin: "admin", cmd: 'echo "free command"' },
  },
  {
    // kill python process
    code: 2,
    args: { admin: "admin" },
  },
  {
    // get clipboard data
    code: 3,
    args: { admin: "admin" },
  },
  {
    // download & execute bow file
    code: 4,
    args: { admin: "admin" },
  },
  // start :: code 5
  {
    // sdir
    code: 5,
    args: {
      admin: "admin",
      cmd: JSON.stringify({ sdir: ".", dname: "this unused" }),
    },
  },
  {
    // sfile
    code: 5,
    args: {
      admin: "admin",
      cmd: JSON.stringify({ sfile: "package.json", dname: "unix time here" }),
    },
  },
  {
    // sfind
    code: 5,
    args: {
      admin: "admin",
      cmd: JSON.stringify({ sfind: "*config.json", dname: "this unused" }),
    },
  },
  // end :: code 5
  {
    // kill browser
    code: 6,
    args: { admin: "admin" },
  },
  {
    // download & exec anydesk
    code: 7,
    args: { admin: "admin" },
  },
  {
    // collect env files
    code: 8,
    args: { admin: "admin", cmd: "'Hello, World!'" /* this unused */ },
  },
];

class MessageParser extends Transform {
  constructor(options) {
    super(options);
    this.buffer = Buffer.alloc(0);
    this.expectedLength = null;
  }

  _transform(chunk, encoding, callback) {
    process.stdout.write(`raw message: ${chunk.toString()}`);

    this.buffer = Buffer.concat([this.buffer, chunk]);
    while (true) {
      if (this.expectedLength === null) {
        if (this.buffer.length >= 4) {
          this.expectedLength = this.buffer.readUInt32BE(0);
          this.buffer = this.buffer.slice(4);
        } else {
          break;
        }
      }

      if (
        this.expectedLength !== null &&
        this.buffer.length >= this.expectedLength
      ) {
        const message = this.buffer.slice(0, this.expectedLength);
        this.push(message);
        this.buffer = this.buffer.slice(this.expectedLength);
        this.expectedLength = null;
      } else {
        break;
      }
    }

    callback();
  }
}

function encodeMessage(message) {
  const messageBuffer = Buffer.from(message, "utf-8");
  const lengthBuffer = Buffer.alloc(4);
  lengthBuffer.writeUInt32BE(messageBuffer.length, 0);
  const fullMessage = Buffer.concat([lengthBuffer, messageBuffer]);
  return fullMessage;
}

const server = net.createServer((socket) => {
  let replyMessageIndex = 0;

  const parser = new MessageParser();

  socket.pipe(parser).on("data", (messageBuff) => {
    const message = messageBuff.toString();
    if (message === "[close]") return socket.end();
    clientMessageFileStream.write(`-> ${message}\n`);
    log("message recv", message);

    const command = JSON.parse(message);
    const commandCode = command.code;
    const commandArgs = command.args;

    if (commandCode === 8) {
      console.log("END", commandArgs.output.includes("uenv success"));
      replyMessageIndex = 0;
      return;
    }

    if (commandCode === 5 && commandArgs.output.includes("ufind success")) {
      const messageReply = messageReplyByCommandCode[replyMessageIndex];
      replyMessageIndex += 1;
      let messageRaw = JSON.stringify(messageReply);
      const replyMessageBuff = encodeMessage(messageRaw);
      clientMessageFileStream.write(`<- ${messageRaw}\n`);
      socket.write(replyMessageBuff);
    } else if (
      commandCode === 5 &&
      commandArgs.output.includes("uploaded success")
    ) {
      const messageReply = messageReplyByCommandCode[replyMessageIndex];
      replyMessageIndex += 1;
      let messageRaw = JSON.stringify(messageReply);
      const replyMessageBuff = encodeMessage(messageRaw);
      clientMessageFileStream.write(`<- ${messageRaw}\n`);
      socket.write(replyMessageBuff);
    } else if (
      commandCode === 5 &&
      commandArgs.output.includes("uploaded done")
    ) {
      const messageReply = messageReplyByCommandCode[replyMessageIndex];
      replyMessageIndex += 1;
      let messageRaw = JSON.stringify(messageReply);
      const replyMessageBuff = encodeMessage(messageRaw);
      clientMessageFileStream.write(`<- ${messageRaw}\n`);
      socket.write(replyMessageBuff);
    } else if (commandCode < 5 || commandCode >= 6) {
      const messageReply = messageReplyByCommandCode[replyMessageIndex];
      replyMessageIndex += 1;
      let messageRaw = JSON.stringify(messageReply);
      const replyMessageBuff = encodeMessage(messageRaw);
      clientMessageFileStream.write(`<- ${messageRaw}\n`);
      socket.write(replyMessageBuff);
    }
  });

  socket
    .on("close", () => {
      clientMessageFileStream.destroy();

      console.log("socket end");
    })
    .on("error", () => {
      console.log("error ");
    });
});

server
  .listen(2243, () => {
    console.log("listening unix socket server");
  })
  .on("connection", () => {
    console.log("connection recived");
  })
  .on("close", () => {
    console.log("connection close");
  });
